token Var (upper (letter | digit)+);
token Proc {"["} (letter)+ {"]"};
terminator Stm ".";
terminator Exp "";
-- separator Exp ",";
-- separator Stm ",";
SExp.  Stm ::= Keyword [Exp];
SCompound. Stm ::= Keyword [Exp] Keyword [Exp];
SBegin. Stm3 ::= "begin" Proc;
SEnd. Stm3 ::= "end" Proc;
-- SKey.  Stm ::= Keyword;

EVar.  Exp ::= Var;
EProc.  Exp ::= Proc;
EStr. Exp ::= String;
EKey. Exp3 ::= Keyword;
EOp. Exp3 ::= Operator;
EType. Exp3 ::= DataType;
EConst. Exp3 ::= Constant;
EInt. Exp2 ::= Integer;
EDoub. Exp2 ::= Double;
EAlgo. Exp4 ::= Algorithm;
ERead. Exp1 ::= "read" Var "from" Constant;

rules Keyword ::=
-- Input
"read" | "obtain" | "get" | "from" | "take" | "use" | "copy" |
-- Output
"print" | "display" | "show" | "save" | "return" |
-- Compute
"compute" | "calculate" | "determine" | "append" | "to" | "over" |
-- Initialize
"set" | "initialize" | "init" | "let" | "is" | "has" | "contains" | "be" |
-- Deviation
"increment" | "bump" | "decrement" |
-- Branching
"if" | "then" | "else" | "otherwise" | "when" | "unless" |
-- While
"while" | "done" | "endwhile" | "do" |
-- Case
"case" | "of" | "others" | "endcase" |
-- Repeat
"repeat" | "until" |
-- For
"for" | "endfor" |
-- Program Flow
"call" | "exception" | "as" | "recurse" | "on" |
-- Selectors
"this" | "that" | "except" | "in" | "at" | "with" | "without" | "aside" |
-- Type Ops
"convert" | "cast" | "ensure" | "expecting" | "expect" |
-- Begin and End and Comma
"begin" | "end" | "," | ":" |
-- Structure Ops
"where" | "containing" |
-- Uncertainty
"either";

rules Constant ::=
-- Booleans
"true" | "false" |
-- Unbound
"nonexistant" | "unbound" | "missing" | "null" |
-- Status
"success" | "failure" | "succeeds" | "fails" | "found" |
-- Formatting
"newline" | "beep" | "indent" |
-- Assumptions
"user" | "screen" | "system";
rules DataType ::=
-- Basics
"number" | "string" | "character" | "boolean" |
-- Extended Boolean
"truthy" | "falsey" |
-- Collections
"list" | "array" | "sequence" | "every" | "each" | "member" | "index" |
"arraylist" |
-- Abstractions
"nothing" | "maybe" | "symbol" | "many" | "any" | "object" |
-- Programming
"constant" | "operator" | "procedure" | "argument" | "parameter" |
-- OS
"file" | "stream" | "pipe" | "port" | "line" | "interrupt" |
-- Programming Refs
"value" | "name" | "result" | "message" | "field" | "an" | "a" | "the" |
-- Structures
"structure" |
-- Plural Basics
"numbers" | "strings" | "characters" | "booleans" |
-- Plural Collections
"lists" | "arrays" | "sequences" | "members" | "indices" |
-- Plural Abstractions
"nothings" | "maybes" | "symbols" | "objects" |
-- Plural Programming
"constants" | "operators" | "procedures" | "arguments" | "parameters" |
-- Plural OS
"files" | "streams" | "pipes" | "ports" | "lines" | "interrupts" |
-- Plural Programming Refs
"values" | "names" | "results" | "messages" | "fields" |
-- Plural Structures
"structures" |
-- Imprecise Basics
"numberish" | "numbery" | "stringish" | "stringy" | "characterish" |
"charactery" | "booleanish" | "booleany" |
-- Imprecise Collections
"listish" | "listy" | "arrayish" | "array-y" | "sequenceish" |
"sequencey" | "memberish" | "membery" | "indexish" | "indexy" |
-- Imprecise Abstractions
"nothingish" | "nothingy" | "maybeish" | "maybe-y" | "symbolish" |
"symboly" | "objectish" | "objecty" |
-- Imprecise Programming
"constantish" | "constanty" | "operatorish" | "operatory" |
"procedureish" | "procedurey" | "argumentish" | "argumenty" |
"parameterish" | "parametery" |
-- Imprecise OS
"fileish" | "filey" | "streamish" | "streamy" | "pipeish" |
"pipey" | "portish" | "porty" | "lineish" | "liney" |
"interruptish" | "interrupty" |
-- Imprecise Programming Refs
"valueish" | "valuey" | "nameish" | "namey" | "resultish" |
"resulty" | "messageish" | "messagey" | "fieldish" | "fieldy" |
-- Imprecise Structures
"structurish" | "structury";

rules Operator ::=
-- Comparison 1
">" | "<" | "==" | "!=" | "<>" | "<=" | ">=" | "=" |
-- Comparison 2
"!<" | "!>" | "≡" | "≯" | "≮" | "≥" | "≤" | "≠" |
-- Arithmetic
"^" | "*" | "+" | "-" | "/" | "%" | "×" | "÷" |
-- Logical
"¬" | "⊻" | "∨" | "∧" | "⍱" | "⍲" |
-- Arrows 1
"<-" | "->" | "<-->" | "→" | "←" | "↑" | "↓" | "⇒" | "⇐" | "⇑" | "⇓" | "↔" |
-- Comparison Words 1
"less than" | "more than" | "greater than" | "equals" |
-- Comparison Words 2
"equal to" | "different than" | "different from" |
-- Arithmetic Words 1
"plus" | "minus" | "times" | "divided by" | "modulo" |
-- Arithmetic Words 4
"squared" | "cubed" | "root" | "square" | "cube" |
-- Logical Words
"not" | "xor" | "and" | "or" | "nand" | "nor" |
-- Arrows Words 1
"resulting in" | "fed to" | "right" | "left" | "leads to" |
-- Arrows Words 2
"results in" | "raise" | "lower" | "share" | "is equivalent to" |
-- Arrows Words 3
"taken from" | "stored in";

rules Algorithm ::=
-- Arithmetic
"sum" | "difference" | "product" | "quotient" | "remainder" | "modulus" |
"sign" | "reciprocal" | "magnitude" | "logarithm" |
-- Statistics
"average" | "mean" | "median" | "mode" | "range" |
-- Extrema
"max" | "maximum" | "min" | "minimum" | "maxima" | "minima" | "ceiling" | "floor" |
-- Search Sort Filter
"sort" | "reverse" | "search" | "find" | "filter in" | "filter out" |
-- Grade Scan Map Reduce
"grade up" | "grade down" | "scan" | "map" | "reduce" | "expand" | "replicate" |
-- Membership
"depth" | "match" | "tally" | "enlist" | "membership" | "pick" | "iota";


coercions Exp 4;
coercions Stm 4;
comment ";";
comment "/*" "*/";
